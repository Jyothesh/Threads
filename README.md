# Threads
Thread Concepts with Example

Executing several tasks simultaneously is called multitasking.

There are two types of multitasking:
1. process based multitasking
2. thread based multitasking


#Process Based Multitasking:
Executing several tasks simultaneously where each task is a separate independent program(process)
Ex: listening to audio songs while working on documentation at the same time
	
#Thread Based Multitasking:
Executing several tasks simultaneously where each task is a separate independent part of the same program, each independent part is called a thread.

The main objective of multitasking is to reduce the response time of system and to improve performance of the program.

Thread is a flow of execution. There is a separate job for every thread.

Two ways of defining threads
1. by extending Thread class
2. by implementing the Runnable class

#By extending Thread class:

#Thread Scheduler
It is part of JVM, It's responsibility is to schedule threads i.e if multiple threads are waiting to get a chance of execution then the priority of threads will be executed by is decided by thread scheduler and execution order varies from JVM to JVM. 

#Difference between t.start and t.run methods!
In case of t.start() a new thread will be created which is responsible for the execution of run method but, in case of t.run() a new thread wont be created and run method will be executed just like a normal method call by main thread. 

#t.start() importance
start method is responsible to register the thread to thread scheduler and all other mandatory activities. Hence, without executing thread class start method there is no chance of starting a new thread in java. Due to this thread class start method is considered as heart of multi threading.

#overloading of run method
overloading of run() is always possible but thread class start method will invoke only no argument run method. The other overloaded method we have to call explicitly like a normal method call.

#not overriding run method
If we are not over riding run method then thread class run method will be executed which has empty implementation. Hence, we wont get any output and it is not recommended to use multithreading concept.

#over riding of start method
If we override start method then our start method will be executed just like a normal method call and new thread wont be created.

It is not recommended to override start method other wise don't go for multithreading.
we can use super.start() to create a new thread in the overrided start method().
 
#Thread life cycle


new/born ----t.start() -->ready/runnable ----thread scheduler allocated processor-->running ---run() ocmpletes--> dead

After starting a thread, if we are trying to restart the same thread, then we get run time exception saying illegalThreadStateException.

#By Implementing Runnable class
We can define a thread by implementing runnable interface.
Runnable interface is present in java.lang package and has only one method run().

We will get mixed output and we can't tell the exact output.

case Study:
ThreadRunnable r = new ThreadRunnable();
Thread t = new Thread();
Thread t1 = new Thread(r);

1. t.start(): a new thread will be created, which is responsible for the execution of Thread class run(), which has empty implementation.
2. t.run(): No new thread will be created and thread class run method will be executed just like a normal method call.
3. t1.start() : a new thread will be created which is responsible for the execution of ThreadRunnable class run() method.
4. t1.run(): No new thread will be created and TheadRunnable run() will be executed just like a normal method call.
5. r.start(): We will get compile time error saying ThreadRUnnable class doesn't have start capability. cannot find symbol method start() location class runnable.
6. r.run() No new thread will be created and ThreadRunnable run() will be executed just like a normal method call.

#Best approach:
Implements Runnable approach is recommended. In the first approach, our class always extends Thread(), there is no chance of extending any other class. Hence, we are missing inheritance benefit, but in second approach we can extend any other class. Hence, we wont miss any inheritance benefit.

#Thread class constructors: 
1. Thread t = new Thread()
2. Thread t = new Thread(Runnable r);
3. Thread t = new Thread(String name);
4. Thread t = new Thread(Runnable r, String name);
5. Thread t = new Thread(ThreadGroup g, string name);
6. Thread t = new Thread(ThreadGroupd g, Runnable r);
7.Thread t = new Thread(ThreadGroup g, Runnable r, string name);
8. Thread t = new Thread(ThreadGroup g, Runnable r, String name, long stackSize);

#Third method():
mythread t = new mythread();
Thread t1 = new Thread(t);
t1.start();

Getting and setting name of a thread:
Every thread in java has some name, it may be default name generated by jvm or customized name provided by programmer.
we can get and set name of a thread by using getName() and setName()
Thread.currentThread() is used to get the current thread.

Every thread in java has some priority, it may be default priority generated by jvm or customized priority provided by programmer. The valid range of thread priority is 1 to 10, where 1 is min priority and 10 is max priority. Thread class defines the following constants to represent some standard priorities Thread.MIN_PRIORITY= 1, NORM_PRIORITY=5, MAX_PRIORITY=10

Thread scheduler will use priorities while allocating processor, highest priority threads will get the chance first. If two threads having same priority then we can't expect exact execution order, it depends on thread scheduler.
Thread class defines the following methods, to get and set priority of a thread by using 

public final int getPriority()
public final void setPriority(int p)

Allowed values range 1 to 10, other wise runtime exception: IllegalArgumentException
The default priority only for the main thread is 5, but for all remaining threads default priority will be inherited from parent to child, i.e what ever priority parent thread has the same priority will be there for the child thread.

We can prevent a thread Execution by using the following methods:
1. yield()
2. join()
3. sleep()

#yield() method
Yield method causes to pause current executed thread and give the chance for waiting threads for same priority. If there is no waiting thread or all waiting threads have low priority then same thread can continue its execution.

If multiple threads are waiting with same priority then we can't expect which waiting thread will get chance and it depends on scheduler.

The threaded which is yielded, we can't get expect when it will get the chance once again, it depends on thread scheduler.

public static native void yield();

In the ThreadYield program, if we are commenting the yield method then both threads will be executed simultaneously and we can't expect which thread will complete first. If we are not commenting yield() then child thread always calls yield method because of that main thread will get chance more number of times and the chance of completing main thread is high.

Some platforms won't provide proper support for yield method.

#join() method 
If a thread wants to wait until completing some other thread, then we should go for join(). 

for example, if a thread t1 wants to wait until completing t2, then t1 has to call t2.join(). If t1 executes t2.join() then immediately t1 will be entered into waiting state until t2 completes. Once t2 completes then t1 can continue its execution.

public final void join();
public final void join(long milisec);
public final void join(long ms, int ns);

Every join method throws InterruptedException() which is checked exception. Hence, we should handle this exception either by using try catch/ throws keyword, otherwise we will get compile time error.

If the thread is waiting/ interrupted or join is done then it goes to ready/runnable state.

1.waiting of main thread until completing child thread(ThreadJoin1.java)
2.waiting of child thread until completing main thread(ThreadJoin.java)
In the above example child thread calls join method on main thread object. hence, child thread has to wait until completing main thread.

3.If main thread calls join method on child thread object, and child thread calls join method on main thread object then both threads will wait for each other forever and the program will be paused. This is something like deadlock.

4.If a thread calls join method on the same thread it self, then the program will be paused(something is deadlock).The thread has to wait infinite amount of time in this case.

#sleep() method:
If a thread don't want to perform any operation for a particular amount of time then we should go for sleep method.

public static native void sleep(long ms);
public static void sleep(long ms, int ns);

Every sleep method throws interrupted exception, which is checked exception. Hence, when ever we are using sleep method we should handle interruptedException either by try-catch/throws keyword for sure, otherwise we will get compile time error.

if time expires or thread gets interrupted, it will enter into ready/runnable state.

#How a thread can interrupt another thread?
A thread can interrupt a sleeping thread or waiting thread by using interrupt method of Thread class.

public void interrupt();

(ThreadInterruption.java)
If we comment thread.interrupt() then main thread won't interrupt child thread, in this case child thread will execute for loop 10 times. If we are not commenting then main thread will interrupt child thread.

->Whenever we are calling interrupt method if the target thread is not in sleeping/waiting state then, there is no impact of interrupt call immediately. Interrupt call will be waited until target thread entered into sleeping or waiting state. If the target thread entered into sleeping or waiting state then immediately interrupt call will interrupt the target thread.

If the target thread never entered into sleeping or waiting state in its life time then there is no impact of interrupt call. This is the only case where interupt call will be wasted.
   
comparision between yield, join and sleep methods:
 